<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>org.scala_tools.subcut.inject.Injectable</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../../lib/template.css" />
      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../../lib/trait_big.png" />
        <p id="owner"><a name="org" class="extype" href="../../../package.html">org</a>.<a name="org.scala_tools" class="extype" href="../../package.html">scala_tools</a>.<a name="org.scala_tools.subcut" class="extype" href="../package.html">subcut</a>.<a name="org.scala_tools.subcut.inject" class="extype" href="package.html">inject</a></p>
        <h1>Injectable</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">trait</span>
      <span class="symbol"> 
        <span class="name">Injectable</span>
        
        <span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
          <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>The trait that provides dependency injection features for a class or object. To use this trait,
Mix it in to the class or object definition, and then define the abstract bindingModule which holds
the bindings to be used. There are several ways to provide these binding modules: simple val override
in the class, mixing in a trait that defines the bindingModule (see BoundToModule), a constructor parameter
or, perhaps most flexibly, an implicit constructor parameter in a curried parameter list. This last option
can provide flexible and mostly invisible bindings all the way down an object instance creation chain.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent">AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a name="org.scala_tools.subcut.inject.AutoInjectable" class="extype" href="AutoInjectable.html">AutoInjectable</a></div>
        </div></div>
        

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show all</span></li></ol>
                <ol id="linearization"><li name="org.scala_tools.subcut.inject.Injectable" class="in"><span>Injectable</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>

        

        
        
        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#bindingModule" data-isabs="true">
      <a id="bindingModule:BindingModule"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">bindingModule</span>
        
        <span class="result">: <a name="org.scala_tools.subcut.inject.BindingModule" class="extype" href="BindingModule.html">BindingModule</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">##</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">clone</span>
        
        <span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">equals</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">finalize</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">getClass</span>
        
        <span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">hashCode</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#inject" data-isabs="false">
      <a id="inject[T](String)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">inject</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="name">name: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type required and an ID string.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type required and an ID string. If there is no
matching binding, this method will throw a BindingException. The string ID is interchangeable with the
symbol version of the same ID, in other words 'maxPoolSize and &quot;maxPoolSize&quot; are considered equivalent by the
lookup mechanism.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait and ID
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#inject" data-isabs="false">
      <a id="inject[T](Symbol)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">inject</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="symbol">symbol: <span name="scala.Symbol" class="extype">Symbol</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type required and an ID symbol.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type required and an ID symbol. If there is no
matching binding, this method will throw a BindingException. The Symbol provided will be converted to a string
prior to the lookup, so the symbol is interchangeable with the string version of the same ID, in other words
'maxPoolSize and &quot;maxPoolSize&quot; are considered equivalent by the lookup mechanism.</p></div><dl class="paramcmts block"><dt class="param">symbol</dt><dd class="cmt"><p>the identifying name to look up for the binding, e.g. 'maxPoolSize</p></dd><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait and ID
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#inject" data-isabs="false">
      <a id="inject[T](Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">inject</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type required.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type required. If there is no binding, this
method will throw a BindingException. This form is for straight trait injection without an identifying name.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfBound" data-isabs="false">
      <a id="injectIfBound[T](Symbol)(⇒ T)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfBound</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="symbol">symbol: <span name="scala.Symbol" class="extype">Symbol</span></span>)</span><span class="params">(<span name="fn">fn: ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance if a binding for that type is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance if a binding for that type is defined. If it is not defined, the function provided will
be used instead to create an instance to be used. This is arguably the most useful and efficient form of
injection usage, as the typical configuration can be provided at the call site and developers can easily
see what the &quot;usual&quot; instance is. An alternative binding will only be used if it is defined, e.g. for testing.
This form of the injector takes a string ID to use in the binding definition lookup, e.g. &quot;maxPoolSize&quot;.</p></div><dl class="paramcmts block"><dt class="param">fn</dt><dd class="cmt"><p>a function to be used to return an instance, if there is no binding defined for the desired trait.</p></dd><dt>returns</dt><dd class="cmt"><p>an instance that subclasses the trait, either from the binding definitions, or using the provided
function if no matching binding is defined.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfBound" data-isabs="false">
      <a id="injectIfBound[T](String)(⇒ T)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfBound</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="name">name: String</span>)</span><span class="params">(<span name="fn">fn: ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance if a binding for that type is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance if a binding for that type is defined. If it is not defined, the function provided will
be used instead to create an instance to be used. This is arguably the most useful and efficient form of
injection usage, as the typical configuration can be provided at the call site and developers can easily
see what the &quot;usual&quot; instance is. An alternative binding will only be used if it is defined, e.g. for testing.
This form of the injector takes a symbol ID to use in the binding definition lookup, e.g. 'maxPoolSize.</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>symbol ID to be used to identify the matching binding definition.</p></dd><dt class="param">fn</dt><dd class="cmt"><p>a function to be used to return an instance, if there is no binding defined for the desired trait.</p></dd><dt>returns</dt><dd class="cmt"><p>an instance that subclasses the trait, either from the binding definitions, or using the provided
function if no matching binding is defined.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfBound" data-isabs="false">
      <a id="injectIfBound[T](⇒ T)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfBound</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="fn">fn: ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance if a binding for that type is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance if a binding for that type is defined. If it is not defined, the function provided will
be used instead to create an instance to be used. This is arguably the most useful and efficient form of
injection usage, as the typical configuration can be provided at the call site and developers can easily
see what the &quot;usual&quot; instance is. An alternative binding will only be used if it is defined, e.g. for testing.
This form of the injector takes only a trait to match and no ID name.</p></div><dl class="paramcmts block"><dt class="param">fn</dt><dd class="cmt"><p>a function to be used to return an instance, if there is no binding defined for the desired trait.</p></dd><dt>returns</dt><dd class="cmt"><p>an instance that subclasses the trait, either from the binding definitions, or using the provided
function if no matching binding is defined.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfMissing" data-isabs="false">
      <a id="injectIfMissing[T](Option[T],Symbol)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfMissing</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="implToUse">implToUse: <span name="scala.Option" class="extype">Option</span>[T]</span>, <span name="symbol">symbol: <span name="scala.Symbol" class="extype">Symbol</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type only if there is no instance already provided.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type only if there is no instance already provided.
If no instance is provided (i.e. the existing impl passed in is null) and no binding is available to match, a
BindingException will be thrown. If an existing impl is provided (not null), then the binding will not be
used and does not need to be present. This form of the inject takes a string ID to use to match the binding.</p></div><dl class="paramcmts block"><dt class="param">implToUse</dt><dd class="cmt"><p>from the call site. If it is null, the binding provider will fill it in instead</p></dd><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfMissing" data-isabs="false">
      <a id="injectIfMissing[T](Option[T],String)(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfMissing</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="implToUse">implToUse: <span name="scala.Option" class="extype">Option</span>[T]</span>, <span name="name">name: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type only if there is no instance already provided.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type only if there is no instance already provided.
If no instance is provided (i.e. the existing impl passed in is null) and no binding is available to match, a
BindingException will be thrown. If an existing impl is provided (not null), then the binding will not be
used and does not need to be present. This form of the inject takes a symbol ID to use to match the binding.</p></div><dl class="paramcmts block"><dt class="param">implToUse</dt><dd class="cmt"><p>from the call site. If it is null, the binding provider will fill it in instead</p></dd><dt class="param">name</dt><dd class="cmt"><p>binding ID symbol to use - e.g. 'maxPoolSize</p></dd><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectIfMissing" data-isabs="false">
      <a id="injectIfMissing[T](Option[T])(Manifest[T]):T"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectIfMissing</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="implToUse">implToUse: <span name="scala.Option" class="extype">Option</span>[T]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an instance for the given trait based on the class type only if there is no instance already provided.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an instance for the given trait based on the class type only if there is no instance already provided.
If no instance is provided (i.e. the existing impl passed in is null) and no binding is available to match, a
BindingException will be thrown. If an existing impl is provided (not null), then the binding will not be
used and does not need to be present. This form of the inject does not need a provided ID symbol or string.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an instance configured by the binding module to use for the given trait
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectOptional" data-isabs="false">
      <a id="injectOptional[T](String)(Manifest[T]):Option[T]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectOptional</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="name">name: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an optional instance for the given trait based on the class type required and an ID string.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an optional instance for the given trait based on the class type required and an ID string. If there is no
matching binding, this method will return None. The string ID is interchangeable with the
symbol version of the same ID, in other words 'maxPoolSize and &quot;maxPoolSize&quot; are considered equivalent by the
lookup mechanism.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an optional instance configured by the binding module to use for the given trait and ID
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectOptional" data-isabs="false">
      <a id="injectOptional[T](Symbol)(Manifest[T]):Option[T]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectOptional</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="symbol">symbol: <span name="scala.Symbol" class="extype">Symbol</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an optional instance for the given trait based on the class type required and an ID symbol.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an optional instance for the given trait based on the class type required and an ID symbol. If there is no
matching binding, this method will return None. The Symbol provided will be converted to a string
prior to the lookup, so the symbol is interchangeable with the string version of the same ID, in other words
'maxPoolSize and &quot;maxPoolSize&quot; are considered equivalent by the lookup mechanism.</p></div><dl class="paramcmts block"><dt class="param">symbol</dt><dd class="cmt"><p>the identifying name to look up for the binding, e.g. 'maxPoolSize</p></dd><dt>returns</dt><dd class="cmt"><p>an optional instance configured by the binding module to use for the given trait and ID
</p></dd></dl></div>
    </li><li visbl="pub" name="org.scala_tools.subcut.inject.Injectable#injectOptional" data-isabs="false">
      <a id="injectOptional[T](Manifest[T]):Option[T]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">injectOptional</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span class="implicit">implicit </span><span name="m">m: <span name="scala.reflect.Manifest" class="extype">Manifest</span>[T]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inject an optional instance for the given trait based on the class type required.</p><div class="fullcomment"><div class="comment cmt"><p>Inject an optional instance for the given trait based on the class type required. If there is no binding, this
method will return None. This form is for straight trait injection without an identifying name.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an optional instance configured by the binding module to use for the given trait.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notify</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notifyAll</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toString</span>
        
        <span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        <div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>